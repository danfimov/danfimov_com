import { parseHTML } from "linkedom";
import * as esbuild from "esbuild";
import { readFileSync } from "node:fs";
import { minify as htmlMinify } from "html-minifier-terser";
import markdownIt from "markdown-it";
import { bundle as lightningcssBundle, browserslistToTargets, Features } from "lightningcss";
import { pd as prettyData } from "pretty-data";
import removeMarkdown from "remove-markdown";
import { load as yamlLoad } from "js-yaml";
import shikiHighlight from "@shikijs/markdown-it";

import anchors from "./src/transforms/anchors.js";
import demos from "./src/transforms/demos.js";
import figure from "./src/transforms/figure.js";
import images from "./src/transforms/images.js";

const globalData = yamlLoad(readFileSync("src/data/global.yml", "utf8"));
const packageJson = JSON.parse(readFileSync("package.json", "utf8"));

const markdown = new markdownIt({ html: true }).use(
  await shikiHighlight({
    defaultColor: false,
    themes: {
      dark: "github-dark",
      light: "github-light",
    },
    transformers: [
      {
        pre(node) {
          delete node.properties.tabindex;
        },
      },
    ],
  }),
);

export default (config) => {
  // Collections

  const collections = {
    articles: "src/articles/*/index.md",
    pages: "src/pages/!(404)/index.njk",
  };

  config.addCollection("articles", (collectionApi) => {
    return collectionApi.getFilteredByGlob(collections.articles);
  });

  config.addCollection("sitemap", (collectionApi) => {
    return collectionApi.getFilteredByGlob([collections.articles, collections.pages]);
  });

  // Markdown

  config.addFilter("markdown", (value) => {
    return markdown.render(value);
  });

  config.addFilter("markdownInline", (value) => {
    return markdown.renderInline(value);
  });

  config.addFilter("markdownRemove", (value) => {
    return removeMarkdown(value);
  });

  config.setLibrary("md", markdown);

  // HTML

  config.addTransform("html-minify", async (content, path) => {
    if (path && path.endsWith(".html")) {
      return await htmlMinify(content, {
        collapseBooleanAttributes: true,
        collapseWhitespace: true,
        decodeEntities: true,
        includeAutoGeneratedTags: false,
        removeComments: true,
      });
    }

    return content;
  });

  const htmlTransforms = [anchors, demos, figure, images];

  config.addTransform("html-transform", async (content, path) => {
    if (path && path.endsWith(".html")) {
      const window = parseHTML(content);

      for (const transform of htmlTransforms) {
        await transform(window, content, path);
      }

      return window.document.toString();
    }

    return content;
  });

  // CSS

  const styles = ["./src/styles/index.css", "./src/styles/light.css", "./src/styles/dark.css"];

  const processStyles = async (path) => {
    return await lightningcssBundle({
      filename: path,
      minify: true,
      sourceMap: false,
      targets: browserslistToTargets(packageJson.browserslist),
      include: Features.MediaQueries | Features.Nesting,
    });
  };

  config.addTemplateFormats("css");

  config.addExtension("css", {
    outputFileExtension: "css",
    compile: async (content, path) => {
      if (!styles.includes(path)) {
        return;
      }

      return async () => {
        let { code } = await processStyles(path);

        return code;
      };
    },
  });

  config.addFilter("css", async (path) => {
    let { code } = await processStyles(path);

    return code;
  });

  // JavaScript

  config.addTemplateFormats("js");

  config.addExtension("js", {
    outputFileExtension: "js",
    compile: async (content, path) => {
      if (path !== "./src/scripts/index.js") {
        return;
      }

      return async () => {
        let { outputFiles } = await esbuild.build({
          target: "es2020",
          entryPoints: [path],
          minify: true,
          bundle: true,
          write: false,
        });

        return outputFiles[0].text;
      };
    },
  });

  // XML minification

  config.addTransform("xmlMin", (content, path) => {
    if (path && path.endsWith(".xml")) {
      return prettyData.xmlmin(content);
    }

    return content;
  });

  // YAML

  config.addDataExtension("yml", (contents) => {
    return yamlLoad(contents);
  });

  // Absolute links

  config.addFilter("absolute", (content, article) => {
    const reg = /(src="[^(https://)])|(src="\/)|(href="[^(https://)])|(href="\/)/g;
    const prefix = globalData.domain + article.url;
    return content.replace(reg, (match) => {
      if (match === 'src="/' || match === 'href="/') {
        match = match.slice(0, -1);
        return match + prefix;
      } else {
        return match.slice(0, -1) + prefix + match.slice(-1);
      }
    });
  });

  // Dates

  config.addFilter("dateLong", (value) => {
    return value.toLocaleString("en", {
      dateStyle: "long",
    });
  });

  config.addFilter("dateShort", (value) => {
    const articleYear = value.getFullYear();
    const currentYear = new Date().getFullYear();
    const dateFormat =
      articleYear < currentYear
        ? {
            dateStyle: "long",
          }
        : {
            month: "long",
            day: "numeric",
          };

    return value.toLocaleString("en", dateFormat);
  });

  config.addFilter("dateISO", (value) => {
    return value.toISOString().split("T")[0];
  });

  // Passthrough copy

  ["src/robots.txt", "src/images", "src/fonts", "src/talks", "src/articles/**/*.!(md|yml)"].forEach((path) =>
    config.addPassthroughCopy(path),
  );

  // Config

  return {
    dir: {
      input: "src",
      output: "dist",
      includes: "includes",
      layouts: "layouts",
      data: "data",
    },
    dataTemplateEngine: "njk",
    markdownTemplateEngine: "njk",
    htmlTemplateEngine: "njk",
    templateFormats: ["md", "njk"],
  };
};
